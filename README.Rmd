---
title: typetracer
output: md_document
---

<!-- badges: start -->
[![R-CMD-check](https://github.com/mpadge/typetracer/workflows/R-CMD-check/badge.svg)](https://github.com/mpadge/typetracer/actions)
[![codecov](https://codecov.io/gh/mpadge/typetracer/branch/main/graph/badge.svg)](https://codecov.io/gh/mpadge/typetracer)
<!-- badges: end -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# typetracer

`typetracer` is an R package to trace function parameter types. The main usage
of `typetracer` is to identify parameters used as input to R functions. Many
computer languages have formal type systems, meaning the types of parameters
must be formally declared and encoded. R is different, and offers no way to
specify the expected types of input parameters. `typetracer` identifies the
types of parameters passed to R functions. The package can trace individual
functions or entire packages, as demonstrated below.

## Installation

The package can be installed with the following command:

```{r remotes, eval = FALSE}
remotes::install_github ("mpadge/typetracer")
```

Then loaded for use by calling `library`:

```{r}
library (typetracer)
```


## Example #1 - A Single Function

`typetracer` works by "injecting" tracing code into the body of a function
using [the `inject_tracer()`
function](https://mpadge.github.io/typetracer/reference/inject_tracer.html).
Locally-defined functions can be traced by simply passing the functions
directly to `inject_tracer()`. The following example includes four parameters,
including `...` to allow passing of additional and entirely arbitrary parameter
types and values.

```{r inject}
f <- function (x, y, z, ...) {
    x * x + y * y
}
inject_tracer (f)
```

After injecting the `typetracer` code, calls to the function, `f`, will "trace"
each parameter of the function, by capturing both unevaluated and evaluated
representations at the point at which the function is first called. These
values can be accessed with [the `load_traces`
function](https://mpadge.github.io/typetracer/reference/load_traces.html),
which returns a `data.frame` object (in [`tibble`
format](https://tibble.tidyverse.org)) with one row for each parameter from
each function call.

```{r trace1}
val <- f (
    x = 1:2,
    y = 3:4 + 0.,
    a = "blah",
    b = list (a = 1, b = "b"),
    f = a ~ b
)
x <- load_traces ()
x
```

That results shows that all parameters of the function, `f()`, were
successfully traced, including the additional parameters, `a`, `b`, and `f`,
passed as part of the `...` argument. Such additional parameters can be
identified through having a `"formal"` entry of `NULL`, indicating that they
are not part of the formal arguments to the function.

The result also includes columns for all parameters both in unevaluated and
evaluated forms. The former captures the parameters as passed to the function
call, while the latter are the equivalent evaluated versions. The following
examples illustrate the differences.

```{r uneval-eval}
x$uneval [x$par_name %in% c ("a", "b")]
x$eval [x$par_name %in% c ("a", "b")]
```

Unevaluated parameters are generally converted to equivalent character
expressions. The `class` and `storage.mode` columns of traces can be used to
convert these back to the type of parameter passed to the function call. The
following code demonstrates how to recover the formula argument, `f = a ~ b`:

```{r formula-recovery}
i <- which (x$storage_mode == "language") # 7
convert_fn <- paste0 ("as.", x$class [i]) # "as.formula"
do.call (convert_fn, list (x$uneval [[i]]))
```

Traces themselves are saved in the temporary directory of the current R
session, and [the `load_traces()`
function](https://mpadge.github.io/typetracer/reference/load_traces.html)
simply loads all traces created in that session. [The function
`clear_traces()`](https://mpadge.github.io/typetracer/reference/clear_traces.html)
removes all traces, so that
[`load_traces()`](https://mpadge.github.io/typetracer/reference/load_traces.html)
will only load new traces produced after that time.

### Uninjecting Traces

It is important after applying [the `inject_tracer()`
function](https://mpadge.github.io/typetracer/reference/inject_tracer.html) to
restore the functions back to their original form through calling [the obverse
`uninject_tracer()`
function](https://mpadge.github.io/typetracer/reference/uninject_tracer.html).
For the function, `r`, above, this simply requires,

```{r}
uninject_tracer (f)
```

Because `typetracer` modifies the internal code of functions as defined within
a current R session, we strongly recommend restarting your R session after
using `typetracer`, to ensure expected function behaviour is restored.


## Example #2 - Tracing a Package

This section presents a more complex example tracing all function calls from
[the `rematch` package](https://github.com/MangoTheCat/rematch), chosen because
it has less code than almost any other package on CRAN. The following single
line traces function calls in all examples for the nominated package. [The
`trace_package()`
function](https://mpadge.github.io/typetracer/reference/trace_package.html)
automatically injects tracing code into every
function within the package, so there is no need to explicitly call [the
`inject_tracer()`
function](https://mpadge.github.io/typetracer/reference/inject_tracer).

```{r trace-rematch, message = FALSE}
res <- trace_package ("rematch")
res
```

The `data.frame` returned by the `trace_package()` function includes one
more column than the result directly returned by `load_traces()`. This column
is called "source", and identifies the source-code object which
generated each trace:

```{r source}
unique (res$source)
```

Tracing an installed package generally only extracts traces from example code,
as documented in help, or `.Rd`, files. These are identified by the "rd_"
prefix on the source call, with the `rematch` package including one one `.Rd`
file.

[The `trace_package()`
function](https://mpadge.github.io/typetracer/reference/trace_package.html)
also includes an additional parameter, `types`, which defaults to `c
("examples", "tests")`, so that traces are also by default generated for all
tests included with local source packages (or for packages installed to include
test files). The "source" column for test files identifies the names of each
test, prefixed with "test_". 

Other than this "source" column, the results are the same as shown above for
`load_traces()`, with one line for every parameter passed to every function
call in the examples. The penultimate two columns of the result hold the
unevaluated and evaluated representations of each parameter. The first two
values of each demonstrate the difference:

```{r rematch-output}
res$uneval [1:2]
res$eval [1:2]
```

The example first assigns a variable `isodaten` to the first of the evaluated
values, and then calls the function with `pattern = isodaten`. The second
constructs the vector called `dates` with the second of the evaluated values,
then calls the function with `test = dates`.

### Example #2(a) - Specifying Functions to Trace

[The `trace_package()`
function](https://mpadge.github.io/typetracer/reference/trace_package.html)
also accepts an argument, `functions`, specifying which functions from a
package should be traced. For example,

```{r trace-stats, eval = FALSE}
x <- trace_package ("stats", functions = c ("sd", "var"))
```
```{r stats-output, echo = FALSE}
par_name <- c ("x", "na.rm", "x", "y", "na.rm",
               "use", "x", "y", "na.rm", "use")
storage.mode <- c ("integer", "logical", "integer", "NULL", "logical",
                   "NULL", "integer", "NULL", "logical", "NULL")
# Create an empty list for formal params. "empty" means an empty name or symbol
# object, which can be conveniently constructed with 'substitute()':
formal <- pairlist (
    x = substitute (),
    na.rm = FALSE,
    y = NULL,
    use = substitute ()
)
formal <- formal [match (par_name, names (formal))]

uneval <- as.list (letters [1:10])
names (uneval) <- par_name
eval <- pairlist (
    x = 1:2,
    na.rm = FALSE,
    x = 1:2,
    y = NULL,
    na.rm = FALSE,
    use = NULL,
    x = 1:10,
    y = NULL,
    na.rm = FALSE,
    y = NULL
)


x <- tibble::tibble (
    fn_name = c (rep ("sd", 2L), rep ("var", 8L)),
    fn_call_hash = c (
        rep ("nNbBzFCg", 2L), rep ("kwTgNeUZ", 4L), rep ("risTCGmw", 4L)),
    par_name = c ("x", "na.rm", "x", "y", "na.rm",
                  "use", "x", "y", "na.rm", "use"),
    class = I (as.list (storage.mode)),
    storage.mode = storage.mode,
    length = as.integer (c (2, 1, 2, 0, 1, 0, 10, 0, 1, 0)),
    formal = formal,
    uneval = I (uneval),
    eval = I (as.list (eval))
)
x
```
