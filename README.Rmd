---
title: typetracer
output: md_document
---

<!-- badges: start -->
[![R-CMD-check](https://github.com/mpadge/typetracer/workflows/R-CMD-check/badge.svg)](https://github.com/mpadge/typetracer/actions)
[![codecov](https://codecov.io/gh/mpadge/typetracer/branch/main/graph/badge.svg)](https://codecov.io/gh/mpadge/typetracer)
<!-- badges: end -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# typetracer

Trace function parameter types in R packages.

```{r}
library (typetracer)
```


## Example #1

Define a function, and use `inject_tracer` to inject parameter tracers used to
trace parameter types on each call. The following function includes an
additional parameter, `z`, which is left undefined here, along with `...` to
allow passing of arbitrary parameter values.

```{r inject}
f <- function (x, y, z, ...) {
    x * x + y * y
}
inject_tracer (f)
```

Calls to the function, `f`, will then trace each parameter of the function. The
current demonstration-only version extracts values for `storage.type` and
`length`. These values can be accessed with the `load_traces` function, with
this example additionally demonstrating:

1. That the additional parameter, `z`, is not traced when left undefined; and
2. That additional parameters passed via `...` are successfully traced.

```{r trace1}
val <- f (x = 1:2, y = 3:4 + 0., a = "blah", b = list (a = 1, b = "b"))
load_traces ()
```

Traces themselves are saved in the temporary directory of the current R
session, and the `load_traces()` function simple loads all traces created in
that session. The function `clear_traces()` removes all traces, so that
`load_traces()` will only load new traces produced after that time.

## Example #2

This section presents a more complex example tracing parameters for a selection
of functions from [the `rematch`
package](https://github.com/MangoTheCat/rematch), chosen because it has less
code than almost any other package on CRAN. The following single line traces
function calls in all examples for the nominated package:

```{r trace-rematch, message = FALSE}
res <- trace_package ("rematch")
res
```

The result contains one line for every parameter passed to every function call
in the examples. The `trace_package()` function also includes an additional
parameter, `types`, which defaults to `c ("examples", "tests")`, so that traces
are also by default generated for all tests included with local source
packages.

The final two columns of the result hold the unevaluated and evaluated
representations of each parameter. The first two values of each demonstrate the
difference:

```{r rematch-output}
res$par_uneval [1:2]
res$par_eval [1:2]
```

The example first assigns a variable `isodaten` to the first of the evaluated
values, and then calls the function with `pattern = isodaten`. The second
constructs the vector called `dates` with the second of the evaluated values,
then calls the function with `test = dates`.

## Examples #3

This example briefly illustrates some examples of tracing parameters evaluated
in non-standards ways. This first examples demonstrates that parameter values
are captured at the initial point of function entry.

```{r nse1}
eval_x_late_NSE <- function (x, y) {
    y <- 10 * y
    eval (substitute (x))
}
inject_tracer (eval_x_late_NSE)
eval_x_late_NSE (y + 1, 2:3)
res <- load_traces ()
res$par_name
res$par_uneval
res$par_eval
```

The parameter `x` is evaluated at the point of function entry as `y + 1` which,
with a value of `y = 2:3`, gives the expected evaluated result of `x = 3:4`,
while the function ultimately returns the expected values of `(10 * 2:3) + 1`,
or `21 31`, because the first line of `y <- 10 * y` is evaluated prior to
substituting the value passed for `x` of `y + 1`.

The second example specifies a default value of `x = y + 1`, with the actual
call passing no value, and thus having `"NULL"` in the unevaluated version,
while evaluated versions remain identical.

```{r nse2}
clear_traces () # clear all preceding traces
eval_x_late_standard <- function (x = y + 1, y, z = y ~ x) {
    y <- 10 * y
    x
}
inject_tracer (eval_x_late_standard)
eval_x_late_standard (, 2:3)
res <- load_traces ()
res$par_name
res$par_uneval
res$par_eval
```

The traces produced by `typetracer` also include a column, `par_formal`, which
contains the default values specified in the definition of
`eval_x_late_standard()`:

```{r}
res$par_formal
```

Those three columns of `par_formal`, `par_uneval`, and `par_eval` thus contain
all definitions for all parameters passed to the function environment, in the three possible states of:

1. Formal or default values (by definition, in an unevaluated state);
2. The unevaluated state of any specified parameters; and
3. The equivalent versions evaluated within the function environmental.
